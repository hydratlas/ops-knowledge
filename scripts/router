#!/bin/bash
setup_netplan () {
    set -eux &&
    local JSON="${1}" &&
    local host_index="" &&
    while read -r index element; do
        if [ "${element}" = "${HOSTNAME}" ]; then
            host_index=${index}
        fi
    done <<< "$(echo "${JSON}" | jq -c -r ".router_host[]" | nl -v 0)" &&
    if [ -z "${host_index}" ]; then
        echo "There is no corresponding host name in the JSON." &&
        exit 1
    fi
    local interface="$(echo "${JSON}" | jq -c -r ".outside.interface[${host_index}]")" &&
    local mac_address="$(echo "${JSON}" | jq -c -r ".outside.mac_address[${host_index}]")" &&
    local ip_address="$(echo "${JSON}" | jq -c -r ".outside.ip_address[${host_index}]")" &&
    local cidr="$(echo "${JSON}" | jq -c -r ".outside.cidr")" &&
    local dns="$(echo "${JSON}" | jq -c ".outside.dns")" &&
    local route="$(echo "${JSON}" | jq -c -r ".outside.route")" &&
    sudo tee "/etc/netplan/90-${interface}.yaml" << EOS > /dev/null &&
network:
  version: 2
  ethernets:
    ${interface}:
      match:
        macaddress: "${mac_address}"
      addresses:
        - "${ip_address}/${cidr}"
      nameservers:
        addresses: ${dns}
      dhcp6: true
      set-name: "${interface}"
      routes:
        - to: "default"
          via: "${route}"
EOS
    sudo chmod go= "/etc/netplan/90-${interface}.yaml" &&
    while read -r index element; do
        local interface="$(echo "${element}" | jq -c -r ".interface[${host_index}]")" &&
        local mac_address="$(echo "${element}" | jq -c -r ".mac_address[${host_index}]")" &&
        local ip_address="$(echo "${element}" | jq -c -r ".ip_address[${host_index}]")" &&
        local cidr="$(echo "${element}" | jq -c -r ".cidr")" &&
        sudo tee "/etc/netplan/90-${interface}.yaml" << EOS > /dev/null &&
network:
  version: 2
  ethernets:
    ${interface}:
      match:
        macaddress: "${mac_address}"
      addresses:
        - "${ip_address}/${cidr}"
      set-name: "${interface}"
EOS
        sudo chmod go= "/etc/netplan/90-${interface}.yaml"
    done <<< "$(echo "${JSON}" | jq -c -r ".inside[]" | nl -v 0)" &&
    set +u &&
    if [ "${SSH_CONNECTION-}" ]; then
        sudo netplan try --timeout 30
    else
        sudo netplan apply
    fi &&
    ip a
    set +eux
}
setup_keepalived () {
    set -eux &&
    local JSON="${1}" &&
    sudo apt-get install -y keepalived &&
    sudo systemctl stop keepalived.service &&
    if ! id keepalived_script; then
        sudo useradd -s /sbin/nologin -M keepalived_script
    fi &&
    sudo tee "/etc/keepalived/check_dnsmasq.sh" << EOS > /dev/null &&
#!/bin/bash
if systemctl is-active --quiet dnsmasq.service; then
  exit 0
else
  exit 1
fi
EOS
    sudo chmod a+x "/etc/keepalived/check_dnsmasq.sh" &&
    sudo tee "/etc/keepalived/restart_dnsmasq.sh" << EOS > /dev/null &&
#!/bin/bash
if systemctl is-active --quiet dnsmasq.service; then
  systemctl stop dnsmasq.service
  sleep 2s # Intervals are kept so that the system is not restarted too many times in a short period of time.
  if ! systemctl is-active --quiet dnsmasq.service; then
    systemctl start dnsmasq.service
  fi
fi
EOS
    sudo chmod a+x "/etc/keepalived/restart_dnsmasq.sh" &&
    sudo tee "/etc/keepalived/keepalived.conf" << EOS > /dev/null &&
include /etc/keepalived/conf.d/*.conf
EOS
    sudo mkdir -p /etc/keepalived/conf.d &&
    sudo tee "/etc/keepalived/conf.d/base.conf" << EOS > /dev/null &&
global_defs {
  enable_script_security
  script_user keepalived_script
}
vrrp_script check_dnsmasq {
  script "/etc/keepalived/check_dnsmasq.sh"
  interval 2
  fall 2
  rise 2
}
EOS
    local host_index="" &&
    while read -r index element; do
        if [ "${element}" = "${HOSTNAME}" ]; then
            host_index=${index}
        fi
    done <<< "$(echo "${JSON}" | jq -c -r ".router_host[]" | nl -v 0)" &&
    if [ -z "${host_index}" ]; then
        echo "There is no corresponding host name in the JSON." &&
        exit 1
    fi
    local vrrp_state="$(echo "${JSON}" | jq -c -r ".vrrp.state[${host_index}]")" &&
    local vrrp_priority="$(echo "${JSON}" | jq -c -r ".vrrp.priority[${host_index}]")" &&
    local vrrp_advert_int="$(echo "${JSON}" | jq -c -r ".vrrp.advert_int")" &&
    while read -r index element; do
        local interface="$(echo "${element}" | jq -c -r ".interface[${host_index}]")" &&
        local virtual_router_id="$(echo "${element}" | jq -c -r ".virtual_router_id")" &&
        local virtual_ip_address="$(echo "${element}" | jq -c -r ".virtual_ip_address")" &&
        local cidr="$(echo "${element}" | jq -c -r ".cidr")" &&
        sudo tee "/etc/keepalived/conf.d/${interface}.conf" << EOS > /dev/null
vrrp_instance VI_${interface} {
  state ${vrrp_state}
  interface ${interface}
  virtual_router_id ${virtual_router_id}
  priority ${vrrp_priority}
  advert_int ${vrrp_advert_int}
  virtual_ipaddress {
    ${virtual_ip_address}/${cidr}
  }
  track_script {
    check_dnsmasq
  }
  #notify_master "/etc/keepalived/restart_dnsmasq.sh"
}
EOS
    done <<< "$(echo "${JSON}" | jq -c -r ".inside[]" | nl -v 0)" &&
    sudo systemctl enable --now keepalived.service &&
    systemctl status --no-pager keepalived.service
    set +eux
    systemctl is-active --quiet keepalived.service
}
setup_nftables () {
    set -eux &&
    local JSON="${1}" &&
    sudo tee /etc/sysctl.d/20-ip-forward.conf << EOS > /dev/null &&
net/ipv4/ip_forward=1
EOS
    sudo sysctl -p /etc/sysctl.d/20-ip-forward.conf &&
    sudo apt-get install -y nftables ipcalc &&
    sudo systemctl stop nftables.service &&
    sudo nft flush ruleset &&
    local host_index="" &&
    while read -r index element; do
        if [ "${element}" = "${HOSTNAME}" ]; then
            host_index=${index}
        fi
    done <<< "$(echo "${JSON}" | jq -c -r ".router_host[]" | nl -v 0)" &&
    if [ -z "${host_index}" ]; then
        echo "There is no corresponding host name in the JSON." &&
        exit 1
    fi
    local outside_interface="$(echo "${JSON}" | jq -c -r ".outside.interface[${host_index}]")" &&
    local outside_ip_address="$(echo "${JSON}" | jq -c -r ".outside.ip_address[${host_index}]")" &&
    sudo nft add table ip filter &&
    sudo nft add chain ip filter INPUT { type filter hook input priority 0 \; } &&
    sudo nft add chain ip filter FORWARD { type filter hook forward priority 0 \; } &&
    sudo nft add chain ip filter OUTPUT { type filter hook output priority 0 \; } &&
    sudo nft add rule ip filter INPUT icmp type echo-request accept && # エコー要求は許可(ping)
    sudo nft add rule ip filter INPUT icmp type echo-reply accept && # エコー応答は許可(ping)
    sudo nft add rule ip filter INPUT iifname "lo" accept && # ローカルホストへの入力トラフィックは許可
    sudo nft add rule ip filter INPUT ct state established,related accept && # 既存の接続や関連の入力トラフィックは許可
    sudo nft add table ip nat &&
    sudo nft add chain ip nat postrouting { type nat hook postrouting priority 100 \; } &&
    while read -r index element; do
        local interface="$(echo "${element}" | jq -c -r ".interface[${host_index}]")" &&
        local ip_address="$(echo "${element}" | jq -c -r ".ip_address[${host_index}]")" &&
        local cidr="$(echo "${element}" | jq -c -r ".cidr")" &&
        local nat_is_enabled=$(echo "${element}" | jq 'if .nat | has("is_enabled") and .is_enabled == true then true else false end') &&
        local network_address="$(ipcalc "${ip_address}/${cidr}" | grep -oP "(?<=^Network:) *[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+")" &&
        network_address="${network_address#"${network_address%%[![:space:]]*}"}" &&
        sudo nft add rule ip filter INPUT iifname "${interface}" ip daddr 224.0.0.18 ip protocol vrrp accept && # Keepalivedに関する入力トラフィックを許可
        sudo nft add rule ip filter INPUT iifname "${interface}" ip saddr "${network_address}/${cidr}" udp dport domain accept && # DNSクエリ(UDP)に関する入力トラフィックを許可
        sudo nft add rule ip filter INPUT iifname "${interface}" ip saddr "${network_address}/${cidr}" tcp dport domain accept && # DNSクエリ(TCP)に関する入力トラフィックを許可
        sudo nft add rule ip filter INPUT iifname "${interface}" udp dport bootps accept && # DHCPリクエストに関する入力トラフィックを許可
        if ${nat_is_enabled}; then
            sudo nft add rule ip filter FORWARD ip saddr "${network_address}/${cidr}" oifname "${outside_interface}" accept && # ローカルネットワークから外部への転送トラフィックは許可
            sudo nft add rule ip filter FORWARD ip daddr "${network_address}/${cidr}" ct state established,related accept && # 外部からローカルネットワークへの関連の転送トラフィックは許可
            sudo nft add rule ip nat postrouting ip saddr "${network_address}/${cidr}" iifname "${interface}" oifname "${outside_interface}" \
            log prefix "\"nft snat: \"" level info \
            snat to "${outside_ip_address}" # SNATを設定
        fi
    done <<< "$(echo "${JSON}" | jq -c -r ".inside[]" | nl -v 0)" &&
    sudo nft add rule ip filter INPUT drop && # その他すべての入力トラフィックを拒否
    sudo nft add rule ip filter FORWARD drop && # その他すべての転送トラフィックを拒否
    sudo nft list ruleset | sudo tee /etc/nftables.conf > /dev/null &&
    sudo systemctl enable --now nftables.service &&
    systemctl status --no-pager nftables.service
    set +eux
    systemctl is-active --quiet nftables.service
}
setup_dnsmasq () {
    set -eux &&
    local JSON="${1}" &&
    sudo apt-get install -y dnsmasq &&
    sudo systemctl stop dnsmasq.service &&
    local elements="$(echo "${JSON}" | jq '.ntp.ip_address[]')" &&
    local dns="$(echo "${JSON}" | jq -r '.outside.dns[] | "server=\(.)"')" &&
    local ntp="$(echo "${JSON}" | jq -r '.ntp.ip_address | join(",")')" &&
    # resolvconfパッケージがインストールされている場合、dnsmasqはシステムのデフォルトリゾルバとして
    # 127.0.0.1配下のdnsmasqを使用するようにresolvconfに伝えるが、その動作を抑制する。
    sudo perl -pe "s/^#?DNSMASQ_EXCEPT=.*\$/DNSMASQ_EXCEPT=lo/g" -i "/etc/default/dnsmasq"
    sudo tee "/etc/dnsmasq.d/base.conf" << EOS > /dev/null &&
# プレーンネーム（ドットやドメイン部分のないもの）を転送しない
domain-needed

# 非ルートアドレス空間のアドレスは転送しない
bogus-priv

# ローカル専用ドメインをここに追加すると、これらのドメインのクエリは/etc/hostsまたはDHCPからのみ応答される。
local=/home.apra/

# hosts-file内の単純な名前にドメインを自動的に追加したい場合は、これを設定する（ドメインも設定する：後述）。
expand-hosts

# dnsmasqのドメインを設定する
domain=home.apra

# /etc/resolv.confを読み込まない→systemd-resolvedを使うため読み込む
#no-resolv

# 上位のDNSサーバーへの参照→systemd-resolvedを使うためいらない
#${dns}

# これをサポートしているシステムでは、dnsmasqは、いくつかのインターフェイスでしかリッスンしていない場合でも、
# ワイルドカードアドレスをバインドする。そして、応答すべきでないリクエストを破棄する。
# これは、インターフェイスが行ったり来たりしてアドレスが変わっても動作するという利点がある。
# dnsmasqがリッスンしているインターフェースだけを本当にバインドしたい場合は、このオプションのコメントを外す。
# このオプションが必要になるのは次のような場合だけである。同じマシン上で別のネームサーバーを実行している場合。
#bind-interfaces

# インターフェースへのバインドを起動時に固定せず、ダイナミックに変更する（bind-interfacesとは併用できない）
bind-dynamic

# loはsystemd-resolvedに任せるため、Dnsmasqでは使わないようにする（これによりbind-interfacesを使わなくてもすむ）
except-interface=lo

# NTPサーバーを公告
dhcp-option=option:ntp-server,${ntp}
EOS
    local TARGET_FILE="/etc/dnsmasq.conf" &&
    local START_MARKER="# BEGIN INCLUDE BLOCK" &&
    local END_MARKER="# END INCLUDE BLOCK" &&
    local CODE_BLOCK=$(cat << EOS
# .confで終わるディレクトリ内のすべてのファイルを読み込む
conf-dir=/etc/dnsmasq.d/,*.conf
EOS
    ) &&
    if ! grep -q "${START_MARKER}" "${TARGET_FILE}"; then
        echo "${START_MARKER}"$'\n'"${CODE_BLOCK}"$'\n'"${END_MARKER}" | sudo tee -a "${TARGET_FILE}" > /dev/null  
    fi &&
    local host_index="" &&
    while read -r index element; do
        if [ "${element}" = "${HOSTNAME}" ]; then
            host_index=${index}
        fi
    done <<< "$(echo "${JSON}" | jq -c -r ".router_host[]" | nl -v 0)" &&
    if [ -z "${host_index}" ]; then
        echo "There is no corresponding host name in the JSON." &&
        exit 1
    fi
    while read -r index element; do
        local interface="$(echo "${element}" | jq -c -r ".interface[${host_index}]")" &&
        local ip_address="$(echo "${element}" | jq -c -r ".ip_address[${host_index}]")" &&
        local cidr="$(echo "${element}" | jq -c -r ".cidr")" &&
        local subnet_mask="$(ipcalc "${ip_address}/${cidr}" | grep -oP "(?<=^Netmask:) *[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+")" &&
        subnet_mask="${subnet_mask#"${subnet_mask%%[![:space:]]*}"}" &&
        local virtual_ip_address="$(echo "${element}" | jq -c -r ".virtual_ip_address")" &&
        local dhcp_range="$(echo "${element}" | jq -r ".dhcp_range[${host_index}] | join(\",\")")" &&
        local dhcp_host_strings=() &&
        while read -r index2 dhcp_host; do
            local dhcp_host_ip_address="$(echo "${dhcp_host}" | jq -c -r ".ip_address")" &&
            local dhcp_host_mac_address="$(echo "${dhcp_host}" | jq -c -r ".mac_address")" &&
            dhcp_host_strings+=("dhcp-host=${interface},${dhcp_host_mac_address},${dhcp_host_ip_address}")
        done <<< "$(echo "${element}" | jq -c -r ".dhcp_hosts[]" | nl -v 0)" &&
        sudo tee "/etc/dnsmasq.d/interface-${interface}.conf" << EOS > /dev/null
# インターフェース
interface=${interface}

# DHCPのアドレスの範囲
dhcp-range=${interface},${dhcp_range},${subnet_mask},24h

# デフォルトルート
dhcp-option=${interface},option:router,${virtual_ip_address}

# DNSサーバー
dhcp-option=${interface},option:dns-server,${virtual_ip_address}

$(printf "%s\n" "${dhcp_host_strings[@]}")
EOS
    done <<< "$(echo "${JSON}" | jq -c -r ".inside[]" | nl -v 0)" &&
    sudo systemctl enable --now dnsmasq.service &&
    systemctl status --no-pager dnsmasq.service
    set +eux
    systemctl is-active --quiet dnsmasq.service
}
